# Plugin System

## Summary

This is a proposal to create an infrastructure to extend the functionality of the Falco libraries via plugins.

Plugins will allow users to easily extend the functionality of the libraries and, as a consequence, of Falco and any other tool based on the libraries.

This proposal, in partcular, focuses on two types of plugins: source plugins and extractor plugins.

## Motivation

[libscap](https://github.com/falcosecurity/libs/tree/master/userspace/libscap) and [libsinsp](https://github.com/falcosecurity/libs/tree/master/userspace/libsinsp) provide a powerful data capture framework, with a rich set of features that includes:

- data capture
- trace files management
- enrichment
- filtering
- formatting and screen rendering
- Lua scripting (chisels)

These features have beed designed with one specific input in mind: system calls. However, they are generically adaptable to a broad set of inputs, such as cloud logs.

With this proposal, we want to dramatically extend the scope of what the libraries, Falco and other tools can be applied to. We want to do it in a way that is easy, efficient and empowers anyone in the community to write an extension.

## Goals

- To design and implement a plugin framework that makes the libraries more modular and extensible
- To have a framework that is easy to use
- To support dynamic loading of plugins, so that the libraries can be extended without having to be recompiled and relinked
- To enable users to write plugins in any language, with a particular focus on Go, C and C++
- To have an efficient plugin framework so that, performance-wise, writing a plugin is as close as possible as extending the libraries internal source code
- To make it possible to write plugins for Linux, MacOS and Windows

## Non-Goals

- To implement plugins other than source and extractor: to be approached as separate task
- To document the plugin framework and interface: to be approached as separate task

## Proposal

### Use cases

- **source plugins**: capture events from arbitrary sources and inject them into the libraries for processing
- **extractor plugins**: export and populate filtercheck-compatible fields from the captured events, that can be used in filters, Falco rules, chisels and more
- save the captured events into trace files that seamlessly encode all of the context required to parse the data

### Plugins format

Plugins are dynamic libraries (.so files in Unix, .dll files in windows) that export a minimum set of functions that the libraries will recognize.

Plugins are versioned using semantic versioning to minimize regressions and compatibility issues.

Plugins can be written in any language, as long as they export the required functions. Go, however, is the preferred language to write plugins, followed by C/C++.

### Protecting from plugin issues

The libraries will do everything possible to validate the data coming from the plugins and protect Falco and the other consumers from corrupted data. However, for performance reasons, plugins will be "trusted": they will run in the same thread and address space as Falco and they could crash the program. We assume that the user will be in control of plugin loading and will make sure only trusted plugins are loaded/packaged with falco.

### Plugin registry

Every plugin requires its own, unique plugin ID to interoperate with Falco and the other plugins. The plugin ID will be used by the libs to properly process incoming events (for example, when save events to file and loading them back), and by plugins to unuambiguosly recognize their dependencies.

To facilitate the allocation and distribution of plugin IDs, we will require that plugin developers request IDs for their plugins to the Falco organization. The mechanism used for plugin allocation is not determined yet and will be discussed in the future.

### golang plugin SDK

To facilitate the development of plugins written in go, an SDK has been developed. We intend this SDK (and future SDKs for other languages) to be part of the falco organization. For this reason, we submitted the following incubation request: https://github.com/falcosecurity/evolution/issues/62

### Proposed API (subject to change)

```c
//
// Initialize the plugin and, if needed, allocate its state.
// Required: no
// Arguments:
// - config: a string with the plugin configuration. The format of the
//   string is chosen by the plugin itself.
// - rc: pointer to an integer that will contain the initialization result,
//   as a SCAP_* value (e.g. SCAP_SUCCESS=0, SCAP_FAILURE=1)
// Return value: pointer to the plugin state that will be treated as opaque
//               by the engine and passed to the other plugin functions.
//
ss_plugin_t* (*init)(char* config, int32_t* rc);
//
// Destroy the plugin and, if plugin state was allocated, free it.
// Required: no
//
void (*destroy)(ss_plugin_t* s);
//
// Return a string with the error that was last generated by the plugin.
// Required: yes
//
char* (*get_last_error)(ss_plugin_t* s);
//
// Return the plugin type.
// Required: yes
// Currently valid types are:
//  TYPE_SOURCE_PLUGIN = 1
//  TYPE_EXTRACTOR_PLUGIN = 2
//
// Source plugins implement a new sinsp/scap event source and MUST export:
// get_type, get_last_error, get_id, get_name, get_description, open, close,
// next and event_to_string. They can optionally also export init, destroy,
// get_fields and extract_str.
//
// Extractor plugins focus on  MUST export: get_type, get_last_error, get_name,
// get_description, get_fields and extract_str
// They can optionally also export init and destroy.
//
uint32_t (*get_type)();
//
// Return the unique ID of the plugin.
// Required: yes
// EVERY SOURCE PLUGIN (see get_type()) MUST OBTAIN AN OFFICIAL ID FROM THE
// FALCO ORGANIZATION, OTHERWISE IT WON'T PROPERLY COEXIST WITH OTHER PLUGINS.
//
uint32_t (*get_id)();
//
// Return the name of the plugin, which will be printed when displaying
// information about the plugin.
// Required: yes
//
char* (*get_name)();
//
// Return the descriptions of the plugin, which will be printed when displaying
// information about the plugin or its events.
// Required: yes
//
char* (*get_description)();
//
// Return the version of the plugin API used by this plugin.
// Required: yes
// Return value: the API version string, in the following format:
//        "<major>.<minor>.<patch>", e.g. "1.2.3".
// NOTE: to ensure correct interoperability between the engine and the plugins,
//       we use a semver approach. Plugins are required to specify the version
//       of the API they run against, and the engine will take care of checking
//       and enforcing compatibility.
//
char* (*get_required_api_version)();
//
// Return the list of extractor fields exported by this plugin. Extractor
// fields can be used in falco rules and sysdig filters.
// This method returns a string with the list of fields encoded as a json
// array.
// Required: for plugins of type TYPE_EXTRACTOR_PLUGIN only
//
char* (*get_fields)();
//
// Open the source and start a capture.
// Required: for plugins of type TYPE_SOURCE_PLUGIN only
// Arguments:
// - s: the plugin state returned by init()
// - params: the open parameters, as a string. The format is defined by the plugin
//   itsef
// - rc: pointer to an integer that will contain the open result, as a SCAP_* value
//   (e.g. SCAP_SUCCESS=0, SCAP_FAILURE=1)
// Return value: a pointer to the open context that will be passed to next(),
// close(), event_to_string() and extract_as_*.
//
ss_instance_t* (*open)(ss_plugin_t* s, char* params, int32_t* rc);
//
// Close a capture.
// Required: for plugins of type TYPE_SOURCE_PLUGIN only
// Arguments:
// - s: the plugin context, returned by init(). Can be NULL.
// - h: the capture context, returned by open(). Can be NULL.
//
void (*close)(ss_plugin_t* s, ss_instance_t* h);
//
// Return the next event.
// Required: for plugins of type TYPE_SOURCE_PLUGIN only
// Arguments:
// - s: the plugin context, returned by init(). Can be NULL.
// - h: the capture context, returned by open(). Can be NULL.
// - data: pointer to a memory buffer pointer. The plugin will set it to point to
//   the memory containing the next event.
// - datalen: pointer to a 32bit integer. The plugin will set it the size of the
//   buffer pointed by data
// - ts: the event timestamp. Can be (uint64_t)-1, in which case the engine will
//   automatically fill the event time with the current time.
// Return value: the status of the operation (e.g. SCAP_SUCCESS=0, SCAP_FAILURE=1,
// SCAP_TIMEOUT=-1)
//
int32_t (*next)(ss_plugin_t* s, ss_instance_t* h, uint8_t** data, uint32_t* datalen, uint64_t* ts);
//
// Return the read progress.
// Required: no
// Arguments:
// - progress_pct: the read progress, as a number between 0 (no data has been read)
//   and 10000 (100% of the data has been read). This encoding allows the engine to
//   print progress decimals without requiring to deal with floating poin numbers
//   (which could cause incompatibility problems with some languages).
// Return value: a string that the plugin can use to customize the progress reporting,
//               or NULL if no custom treatment is required.
// NOTE: reporting progress is optional and in some case could be impossible. However,
//       when possible, it's recommended as it provides valuable information to the
//       user.
//
char* (*get_progress)(ss_plugin_t* s, ss_instance_t* h, uint32_t* progress_pct);
//
// Return a text representation of an event generated by this source plugin.
// Required: for plugins of type TYPE_SOURCE_PLUGIN only
// Arguments:
// - data: the buffer produced by next().
// - datalen: the length of the buffer produced by next().
// Return value: the text representation of the event This is used, for example,
// by sysdig to print a line for the given event.
//
char *(*event_to_string)(ss_plugin_t *s, uint8_t *data, uint32_t datalen);
//
// Extract a filter field value from an event.
// We offer multiple versions of extract(), differing from each other only in
// the type of the value they return (string, integer...).
// Required: for plugins of type TYPE_EXTRACTOR_PLUGIN only
// Arguments:
// - evtnum: the number of the event that is bein processed
// - id: the numeric identifier of the field to extract. It corresponds to the
//   position of the field in the array returned by get_fields().
// - arg: the field argument, if an argument has been specified for the field,
//   otherwise it's NULL. For example:
//    * if the field specified by the user is foo.bar[pippo], arg will be the
//      string "pippo"
//    * if the field specified by the user is foo.bar, arg will be NULL
// - data: the buffer produced by next().
// - datalen: the length of the buffer produced by next().
// - field_present: nonzero if the field is present for the given event.
// Return value: the produced value of the filter field. For extract_str(), a
// NULL return value means that the field is missing for the given event.
//
char *(*extract_str)(ss_plugin_t *s, uint64_t evtnum, uint32_t id, char *arg, uint8_t *data, uint32_t datalen);
uint64_t (*extract_u64)(ss_plugin_t *s, uint64_t evtnum, uint32_t id, char *arg, uint8_t *data, uint32_t datalen, uint32_t *field_present);
//
// This is an optional, internal, function used to speed up event capture by
// batching the calls to next()
// Required: no
//
int32_t (*next_batch)(ss_plugin_t* s, ss_instance_t* h, uint8_t** data, uint32_t* datalen);
//
// This is an optional, internal, function used to speed up value extraction
// Required: no
//
int32_t (*register_async_extractor)(ss_plugin_t *s, async_extractor_info *info);
```

### Plugin types

Initially, we will implement support for two types of plugins: source plugins and extractor plugins.

A plugin declare its type by implementing the mandatory `get_type` function.

Source plugins implement a new sinsp/scap event source and MUST export: `get_type`, `get_last_error`, `get_id`, `get_name`, `get_description`, `open`, `close`,
`next` and `event_to_string`. They can optionally also export `init`, `destroy`,
`get_fields` and `extract_str`.

Extractor plugins focus on fields extraction and MUST export: `get_type`, `get_last_error`, `get_name`,
`get_description`, `get_fields` and `extract_str`.
They can optionally also export `init` and `destroy`.

### Loading the plugins

The mechanics of loading a plugin are implemented in the libraries and leverage the dynamic library functionality of the operating system (dlopen/dlsym in unix, LoadLibrary/GetProcAddress in Windows). The plugin loading code also ensures that:

- the pluging is valid, i.e. that it exports the set of expected symbols
- the plugin has a version number that is compatible with the libraries instance
- if the loaded plugin is an extractor plugin, the exported fields have unique names that don't clash with existing ones

Callers of the libraries have the flexibility to control what is loaded and from where. For example, some tools line Falco will let the user configure the plugins to load in a YAML configuration file, while other tools might use the command line.

### Examples

https://github.com/leogr/plugins/tree/master/plugins/cloudtrail

This Go plugin implements an AWS cloudtrail source .

It implements fetching cloudtrail data from an S3 bucket, and exports a number of fields that can be used in filters or rules.

## Links

[PR with the initial implementation](https://github.com/falcosecurity/libs/pull/33)

[Incubation request for the Go plugin SDK](https://github.com/falcosecurity/evolution/issues/62)